#
# Sykube image
#

Bootstrap: docker
From: ubuntu:18.04

%environment
    export PATH=/opt/go/bin:$PATH
    export GOPATH=/opt/gopath
    export KUBECONFIG=/etc/kubernetes/admin.conf
    
%setup
    mkdir $SINGULARITY_ROOTFS/etc/sykube
    cp --preserve=mode sykube $SINGULARITY_ROOTFS/etc/sykube
    cat > $SINGULARITY_ROOTFS/etc/hosts <<EOF
127.0.0.1   localhost

::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
EOF

%post
    apt-get update -y && apt-get install -y --no-install-recommends apt-transport-https ca-certificates curl software-properties-common gnupg2 lsb-release wget
    curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
    echo "deb http://apt.kubernetes.io/ kubernetes-xenial main" > /etc/apt/sources.list.d/kubernetes.list
    apt-get update -y
    apt-get install -y --no-install-recommends supervisor iproute2 iputils-ping ethtool ebtables kmod
    apt-get install -y --no-install-recommends kubelet=1.21.0-00 kubectl=1.21.0-00 kubeadm=1.21.0-00
    apt-get install -y --no-install-recommends squashfs-tools libssl-dev uuid-dev libseccomp-dev libseccomp2
    apt-get install -y --no-install-recommends gcc make git pkg-config less cryptsetup

    rm -rf /var/log/*

    mkdir /etc/supervisor/available.d/

    cat > /etc/supervisor/available.d/singularity-cri.conf <<EOF
[program:cri]
command=/usr/local/bin/sycri -v=10
priority=10
autostart=true
startsecs=1
autorestart=true
stdout_logfile=/var/log/singularity-cri.out
stderr_logfile=/var/log/singularity-cri.err
environment=PATH="/usr/local/libexec/singularity/bin:/bin:/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin"
EOF
    ln -s /etc/supervisor/available.d/singularity-cri.conf /etc/supervisor/conf.d/singularity-cri.conf

    cat > /etc/supervisor/available.d/kubelet.conf <<EOF
[program:kubelet]
priority=100
command=/usr/bin/kubelet-wrapper
autostart=true
startsecs=10
startretries=360
autorestart=true
stdout_logfile=/var/log/kubelet.out
stderr_logfile=/var/log/kubelet.err
EOF
    ln -s /etc/supervisor/available.d/kubelet.conf /etc/supervisor/conf.d/kubelet.conf

    cat > /etc/supervisor/available.d/kube-proxy.conf <<EOF
[program:kube-proxy]
command=/usr/bin/kube-proxy-wrapper
autostart=true
startsecs=10
startretries=360
autorestart=true
stdout_logfile=/var/log/kube-proxy.out
stderr_logfile=/var/log/kube-proxy.err
EOF

    cat > /usr/bin/kube-proxy-wrapper <<EOF
#!/bin/sh

if [ -f "/etc/kubernetes/admin.conf" ]; then
    export KUBECONFIG="/etc/kubernetes/admin.conf"
    exec /usr/bin/kubectl proxy --address=10.11.11.2
fi

exit 1
EOF
    chmod 755 /usr/bin/kube-proxy-wrapper

    cat > /usr/bin/kubelet-wrapper <<EOF
#!/bin/sh

KUBELET_EXTRA_ARGS="--container-runtime=remote --container-runtime-endpoint=/var/run/singularity.sock --image-service-endpoint=/var/run/singularity.sock --fail-swap-on=false"
KUBELET_KUBECONFIG_ARGS="--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf"
KUBELET_CONFIG_ARGS="--config=/var/lib/kubelet/config.yaml"

exec /usr/bin/kubelet \$KUBELET_KUBECONFIG_ARGS \$KUBELET_CONFIG_ARGS \$KUBELET_EXTRA_ARGS
EOF
    chmod 755 /usr/bin/kubelet-wrapper

    cat > /usr/bin/service-sup <<EOF
#!/bin/sh

case "\$1" in
    disable)
        if [ -f "/etc/supervisor/conf.d/\$2.conf" ]; then
            rm /etc/supervisor/conf.d/\$2.conf
            supervisorctl update
        else
            echo "no service found for \$2"
            exit 1
        fi
    ;;
    enable)
        if [ -f "/etc/supervisor/available.d/\$2.conf" ]; then
            ln -s /etc/supervisor/available.d/\$2.conf /etc/supervisor/conf.d/\$2.conf
            supervisorctl update
        else
            echo "no service found for \$2"
            exit 1
        fi
    ;;
    *)
        echo "usage service-sup enable|disable service"
        exit 1
    ;;
esac
EOF
    chmod 755 /usr/bin/service-sup

    curl https://dl.google.com/go/go1.16.1.linux-amd64.tar.gz | tar -C /opt -xz
    export PATH=/opt/go/bin:$PATH
    export GOPATH=/opt/gopath

    mkdir -p /opt/gopath
    cd /opt

    git clone https://github.com/sylabs/singularity-cri  
    git clone https://github.com/sylabs/singularity -b v3.5.2

    export HOME=/tmp
    cd /opt/singularity-cri
    git checkout tags/v1.0.0-beta.7 -b v1.0.0-beta.7
    rm go.mod
    cat > go.mod <<EOF
module github.com/sylabs/singularity-cri

go 1.11

require (
        github.com/NVIDIA/gpu-monitoring-tools v0.0.0-20190227022151-81c885550fa1
        github.com/checkpoint-restore/go-criu v4.0.0+incompatible // indirect
        github.com/containerd/cgroups v0.0.0-20181219155423-39b18af02c41
        github.com/containerd/console v1.0.3 // indirect
        github.com/containernetworking/cni v0.7.1
        github.com/creack/pty v1.1.9
        github.com/docker/spdystream v0.0.0-20181023171402-6480d4af844c // indirect
        github.com/elazarl/goproxy v0.0.0-20181111060418-2ce16c963a8a // indirect
        github.com/emicklei/go-restful v2.8.0+incompatible // indirect
        github.com/fsnotify/fsnotify v1.4.7
        github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b
        github.com/google/gofuzz v0.0.0-20170612174753-24818f796faf // indirect
        github.com/hashicorp/go-cleanhttp v0.5.1 // indirect
        github.com/hashicorp/go-multierror v1.0.0 // indirect
        github.com/json-iterator/go v1.1.5 // indirect
        github.com/kr/pty v1.1.8
        github.com/kubernetes-sigs/cri-o v1.12.3
        github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
        github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742 // indirect
        github.com/mrunalp/fileutils v0.5.0 // indirect
        github.com/opencontainers/image-spec v1.0.1
        github.com/opencontainers/runc v1.0.0-rc8.0.20190826210544-c61c7370f960
        github.com/opencontainers/runtime-spec v0.1.2-0.20181111125026-1722abf79c2f
        github.com/opencontainers/runtime-tools v0.9.0
        github.com/opencontainers/selinux v1.3.0
        github.com/stretchr/testify v1.4.0
        github.com/sylabs/scs-library-client v0.4.4
        github.com/sylabs/singularity v0.0.0-20191217142513-180ecff2a4b3
        github.com/syndtr/gocapability v0.0.0-20180916011248-d98352740cb2 // indirect
        github.com/tchap/go-patricia v2.3.0+incompatible
        github.com/xeipuuv/gojsonschema v0.0.0-20180816142147-da425ebb7609 // indirect
        golang.org/x/crypto v0.0.0 // indirect
        golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c
        google.golang.org/genproto v0.0.0-20181109154231-b5d43981345b // indirect
        google.golang.org/grpc v1.20.0
        gopkg.in/inf.v0 v0.9.1 // indirect
        gopkg.in/yaml.v2 v2.2.4
        gotest.tools v2.3.0+incompatible // indirect
        k8s.io/api v0.0.0-20181121071145-b7bd5f2d334c // indirect
        k8s.io/apimachinery v0.0.0-20181126123124-70adfbae261e // indirect
        k8s.io/apiserver v0.0.0-20181121231732-e3c8fa95bba5 // indirect
        k8s.io/client-go v0.0.0-20181010045704-56e7a63b5e38
        k8s.io/klog v0.2.0 // indirect
        k8s.io/kubernetes v1.12.5
        
        replace (
        github.com/sylabs/scs-key-client v0.3.0-0.20190509220229-bce3b050c4ec => github.com/sylabs/scs-key-client v0.3.1-0.20190509220229-bce3b050c4ec
        golang.org/x/crypto => github.com/sylabs/golang-x-crypto v0.0.0-20181006204705-4bce89e8e9a9
)

EOF
    rm pkg/server/device/device.go
    cat > pkg/server/device/device.go <<EOF
// Copyright (c) 2018-2019 Sylabs, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Portions of this file were derived from github.com/nvidia/k8s-device-plugin
// under the following license:
//
// Copyright (c) 2017, NVIDIA CORPORATION. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
// * Neither the name of NVIDIA CORPORATION nor the names of its
// contributors may be used to endorse or promote products derived
// from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package device

import (
	"context"
	"fmt"
	"os/exec"

	"github.com/NVIDIA/gpu-monitoring-tools/bindings/go/nvml"
	"github.com/golang/glog"
	"github.com/sylabs/singularity-cri/pkg/singularity"
	"github.com/sylabs/singularity-cri/pkg/singularity/runtime"
	"github.com/sylabs/singularity/pkg/util/gpu"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	k8sDP "k8s.io/kubernetes/pkg/kubelet/apis/deviceplugin/v1beta1"
)

var (
	// ErrNoGPUs is returned when device plugin is unable to
	// detect any GPU device on the host.
	ErrNoGPUs = fmt.Errorf("GPUs are not found on this host")

	// ErrUnableToLoad is returned when device plugin is unable to
	// detect loaded graphic driver on the host or unable to load
	// NVML shared library.
	ErrUnableToLoad = fmt.Errorf("unable to load: check libnvidia-ml.so.1 library and graphic drivers")
)

// SingularityDevicePlugin is Singularity implementation of a DevicePluginServer
// interface that allows containers to request nvidia GPUs.
type SingularityDevicePlugin struct {
	devices  map[string]*nvml.Device
	hospital map[string]string
	confDir  string

	done         chan struct{}
	unhealthyDev <-chan string
}

// NewSingularityDevicePlugin initializes and returns Singularity device plugin
// that allows us to access nvidia GPUs on host. It fails if there is no
// graphic driver installed on host or if Nvidia Management Library (NVML)
// fails to load.
func NewSingularityDevicePlugin() (*SingularityDevicePlugin, error) {
	_, err := exec.LookPath(singularity.RuntimeName)
	if err != nil {
		return nil, fmt.Errorf("could not find %s on this machine: %v", singularity.RuntimeName, err)
	}
	config, err := runtime.NewCLIClient().BuildConfig()
	if err != nil {
		return nil, fmt.Errorf("could not get build config: %v", err)
	}

	glog.V(1).Infof("Loading NVML")
	if err = nvml.Init(); err != nil {
		glog.Errorf("Could not initialize NVML library: %v", err)
		return nil, ErrUnableToLoad
	}

	dp := &SingularityDevicePlugin{
		done:    make(chan struct{}),
		confDir: config.SingularityConfdir,
	}
	defer func() {
		if err != nil {
			glog.Errorf("Shutting down device plugin due to %v", err)
			dp.Shutdown()
		}
	}()

	v, err := nvml.GetDriverVersion()
	if err != nil {
		glog.Errorf("Could not get driver version: %v", err)
		return nil, ErrUnableToLoad
	}
	glog.V(1).Infof("Found graphic driver of version %v", v)

	devices, err := getDevices()
	if err != nil {
		return nil, fmt.Errorf("could not get available devices: %v", err)
	}
	if len(devices) == 0 {
		return nil, ErrNoGPUs
	}

	dp.devices = make(map[string]*nvml.Device, len(devices))
	dp.hospital = make(map[string]string, len(devices))
	devIDs := make([]string, len(devices))
	for i, dev := range devices {
		dp.devices[dev.UUID] = dev
		dp.hospital[dev.UUID] = k8sDP.Healthy
		devIDs[i] = dev.UUID
	}

	dp.unhealthyDev, err = monitorGPUs(dp.done, devIDs)
	if err != nil {
		return nil, fmt.Errorf("could not start GPU monitoring: %v", err)
	}

	return dp, nil
}

// Shutdown shuts down device plugin and any GPU monitoring activity.
func (dp *SingularityDevicePlugin) Shutdown() error {
	glog.V(3).Infof("Cancelling GPU monitoring")
	close(dp.done)
	return nvml.Shutdown()
}

// GetDevicePluginOptions returns options to be communicated with Device Manager.
func (*SingularityDevicePlugin) GetDevicePluginOptions(context.Context, *k8sDP.Empty) (*k8sDP.DevicePluginOptions, error) {
	return &k8sDP.DevicePluginOptions{}, nil
}

// ListAndWatch returns a stream of List of Devices. Whenever a Device state changes
// or a Device disappears, ListAndWatch returns the new list.
func (dp *SingularityDevicePlugin) ListAndWatch(_ *k8sDP.Empty, srv k8sDP.DevicePlugin_ListAndWatchServer) error {
	devList := dp.listK8sDevices()
	glog.V(3).Infof("Sending initial device list: %v", devList)
	err := srv.Send(&k8sDP.ListAndWatchResponse{Devices: devList})
	if err != nil {
		return status.Errorf(codes.Unknown, "could not send initial devices state: %v", err)
	}
	for {
		select {
		case <-dp.done:
			return nil
		case devID := <-dp.unhealthyDev:
			dp.hospital[devID] = k8sDP.Unhealthy
			glog.Warningf("Device %s is in hospital", devID)

			err := srv.Send(&k8sDP.ListAndWatchResponse{Devices: dp.listK8sDevices()})
			if err != nil {
				return status.Errorf(codes.Unknown, "could not send updated devices state: %v", err)
			}
		}
	}
}

// Allocate is called during container creation so that the Device Plugin can run
// device specific operations and instruct Kubelet of the steps to make the Device
// available in the container.
func (dp *SingularityDevicePlugin) Allocate(ctx context.Context, req *k8sDP.AllocateRequest) (*k8sDP.AllocateResponse, error) {
	nvLibs, nvBins, err := gpu.NvidiaPaths(dp.confDir, "")
	if err != nil {
		return nil, status.Errorf(codes.Internal, "could not search NVIDIA files: %v", err)
	}
	glog.V(4).Infof("NVIDIA paths are %v and %v", nvLibs, nvBins)

	nvDevs, err := gpu.NvidiaDevices(false)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "could not search NVIDIA complementary devices: %v", err)
	}
	glog.V(4).Infof("NVIDIA complementary devices are %v", nvDevs)

	nvidiaMounts := make([]*k8sDP.Mount, 0, len(nvLibs)+len(nvBins))
	for _, libPath := range nvLibs {
		nvidiaMounts = append(nvidiaMounts, &k8sDP.Mount{
			ContainerPath: libPath,
			HostPath:      libPath,
			ReadOnly:      true,
		})
	}
	for _, binPath := range nvBins {
		nvidiaMounts = append(nvidiaMounts, &k8sDP.Mount{
			ContainerPath: binPath,
			HostPath:      binPath,
			ReadOnly:      true,
		})
	}

	allocateResponses := make([]*k8sDP.ContainerAllocateResponse, 0, len(req.ContainerRequests))
	for _, allocateRequest := range req.ContainerRequests {
		nvidiaDevices := make([]*k8sDP.DeviceSpec, 0, len(nvDevs)+len(allocateRequest.DevicesIDs))
		for _, nvDev := range nvDevs {
			nvidiaDevices = append(nvidiaDevices, &k8sDP.DeviceSpec{
				ContainerPath: nvDev,
				HostPath:      nvDev,
				Permissions:   "rw",
			})
		}
		for _, devID := range allocateRequest.DevicesIDs {
			device := dp.devices[devID]
			nvidiaDevices = append(nvidiaDevices, &k8sDP.DeviceSpec{
				ContainerPath: device.Path,
				HostPath:      device.Path,
				Permissions:   "rw",
			})
		}
		allocateResponses = append(allocateResponses, &k8sDP.ContainerAllocateResponse{
			Mounts:  nvidiaMounts,
			Devices: nvidiaDevices,
		})
	}
	return &k8sDP.AllocateResponse{
		ContainerResponses: allocateResponses,
	}, nil
}

// PreStartContainer is called, if indicated by Device Plugin during registration phase,
// before each container start. Device plugin can run device specific operations
// such as resetting the device before making devices available to the container.
func (*SingularityDevicePlugin) PreStartContainer(context.Context, *k8sDP.PreStartContainerRequest) (*k8sDP.PreStartContainerResponse, error) {
	return &k8sDP.PreStartContainerResponse{}, nil
}

func (dp *SingularityDevicePlugin) listK8sDevices() []*k8sDP.Device {
	devices := make([]*k8sDP.Device, 0, len(dp.hospital))
	for devID, health := range dp.hospital {
		devices = append(devices, &k8sDP.Device{
			ID:     devID,
			Health: health,
		})
	}
	return devices
}
EOF
    rm Makefile
    cat > Makefile <<EOF
# silent build
V := @

BIN_DIR := ./bin
SY_CRI := $(BIN_DIR)/sycri
SY_CRI_TEST := $(BIN_DIR)/sycri.test

INSTALL_DIR := /usr/local/bin
SY_CRI_INSTALL := $(INSTALL_DIR)/sycri

CRI_CONFIG := ./config/sycri.yaml
CRI_CONFIG_INSTALL := /usr/local/etc/sycri/sycri.yaml

SECCOMP = "$(shell printf "\#include <seccomp.h>\nint main() { seccomp_syscall_resolve_name(\"read\"); }" | gcc -x c -o /dev/null - -lseccomp >/dev/null 2>&1; echo $$?)"

all: $(SY_CRI)

$(SY_CRI):
	@echo " GO" $@
	@if [ $(SECCOMP) -eq "0" ] ; then \
		_=$(eval BUILD_TAGS = seccomp) ; \
	else \
		echo " WARNING: seccomp is not found, ignoring" ; \
	fi
	$(V)GOOS=linux go build -mod mod -tags "sylog selinux $(BUILD_TAGS)" \
		-ldflags "-X main.version=`(git describe --tags --dirty --always 2>/dev/null || echo "unknown") \
		| sed -e "s/^v//;s/-/_/g;s/_/-/;s/_/./g"`" \
		-o $(SY_CRI) ./cmd/server

install: $(SY_CRI_INSTALL) $(CRI_CONFIG_INSTALL)

$(SY_CRI_INSTALL):
	@echo " INSTALL" $@
	$(V)install -d $(@D)
	$(V)install -m 0755 $(SY_CRI) $(SY_CRI_INSTALL)

$(CRI_CONFIG_INSTALL):
	@echo " INSTALL" $@
	$(V)install -d $(@D)
	$(V)install -m 0644 $(CRI_CONFIG) $(CRI_CONFIG_INSTALL)

.PHONY: clean
clean:
	@echo " CLEAN"
	$(V)go clean -mod mod
	$(V)rm -rf $(BIN_DIR)

.PHONY: uninstall
uninstall:
	@echo " UNINSTALL"
	$(V)rm -rf $(SY_CRI_INSTALL) $(CRI_CONFIG_INSTALL)

.PHONY: test
test:
	$(V)GOOS=linux go test -mod mod -v -coverprofile=cover.out -race ./...

$(SY_CRI_TEST):
	@echo " GO" $@
	@if [ $(SECCOMP) -eq "0" ] ; then \
		_=$(eval BUILD_TAGS = seccomp) ; \
	else \
		echo " WARNING: seccomp is not found, ignoring" ; \
	fi
	$(V)GOOS=linux go test -mod mod -c -o $(SY_CRI_TEST) -tags "selinux $(BUILD_TAGS) testrunmain" \
	-coverpkg=./... ./cmd/server


GOBIN = $(shell go env GOPATH)/bin
LINTER = $(GOBIN)/golangci-lint
LINTER_VERSION := v1.19.1

.PHONY: linter-install
linter-install:
	@echo " INSTALL" $(LINTER) $(LINTER_VERSION)
	$(V)curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s -- -b $(GOBIN) $(LINTER_VERSION)

.PHONY: lint
lint:
	$(V) [ ! -x $(LINTER) ] && \
	 echo 'Linter is not installed, run `make linter-install`' && \
	 exit 1 || true
	@echo " RUNNING LINTER"
	$(V)$(LINTER) run --config .golangci.local.yml

.PHONY: dep
dep:
	$(V)go mod tidy
	$(V)go mod mod
EOF

 
    rm pkg/image/image.go
    cat > pkg/image/image.go <<EOF
// Copyright (c) 2018-2019 Sylabs, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package image

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"github.com/golang/glog"
	specs "github.com/opencontainers/image-spec/specs-go/v1"
	library "github.com/sylabs/scs-library-client/client"
	"github.com/sylabs/singularity-cri/pkg/rand"
	"github.com/sylabs/singularity-cri/pkg/singularity"
	"github.com/sylabs/singularity-cri/pkg/slice"
	"github.com/sylabs/singularity/pkg/image"
	"github.com/sylabs/singularity/pkg/signing"
	k8s "k8s.io/kubernetes/pkg/kubelet/apis/cri/runtime/v1alpha2"
)

const (
	// IDLen reflects number of symbols in image unique ID.
	IDLen = 64
)

var (
	// ErrIsUsed notifies that image is currently being used by someone.
	ErrIsUsed = fmt.Errorf("image is being used")
	// ErrNotFound notifies that image is not found thus cannot be pulled.
	ErrNotFound = fmt.Errorf("image is not found")
	// ErrNotLibrary is used when user tried to get library image metadata but
	// provided non library image reference.
	ErrNotLibrary = fmt.Errorf("not library image")
)

// Info represents image stored on the host filesystem.
type Info struct {
	ID        string             `json:"id"`
	Sha256    string             `json:"sha256"`
	Size      uint64             `json:"size"`
	Path      string             `json:"path"`
	Ref       *Reference         `json:"ref"`
	OciConfig *specs.ImageConfig `json:"ociConfig,omitempty"`

	mu     sync.RWMutex
	usedBy []string
}

// Borrow notifies that image is used by some container and should
// not be removed until Return with the same parameters is called.
// This method is thread-safe to use.
func (i *Info) Borrow(who string) {
	i.mu.Lock()
	defer i.mu.Unlock()

	i.usedBy = slice.MergeString(i.usedBy, who)
}

// Return notifies that image is no longer used by a container and
// may be safely removed if no one else needs it anymore.
// This method is thread-safe to use.
func (i *Info) Return(who string) {
	i.mu.Lock()
	defer i.mu.Unlock()

	i.usedBy = slice.RemoveFromString(i.usedBy, who)
}

// UsedBy returns list of container ids that use this image.
func (i *Info) UsedBy() []string {
	i.mu.RLock()
	defer i.mu.RUnlock()

	usedBy := make([]string, len(i.usedBy))
	copy(usedBy, i.usedBy)
	return usedBy
}

// Pull pulls image referenced by ref and saves it to the passed location.
func Pull(ctx context.Context, location string, ref *Reference, auth *k8s.AuthConfig) (*Info, error) {
	if ref.URI() == singularity.LocalFileDomain {
		info, err := sifInfo(strings.TrimPrefix(ref.tags[0], singularity.LocalFileDomain))
		if err != nil {
			return nil, fmt.Errorf("could not fetch local SIF info: %v", err)
		}
		info.Ref = ref
		return info, nil
	}

	pullPath := filepath.Join(location, "."+rand.GenerateID(64))
	glog.V(5).Infof("Pulling %s to temporary file %s", ref, pullPath)
	cleanup := func() {
		if err := os.Remove(pullPath); err != nil && !os.IsNotExist(err) {
			glog.Errorf("Could not remove %s: %v", pullPath, err)
		}
	}

	err := pullImage(ctx, ref, auth, pullPath)
	if err != nil {
		cleanup()
		return nil, fmt.Errorf("could not pull image: %v", err)
	}
	info, err := sifInfo(pullPath)
	if err != nil {
		cleanup()
		return nil, fmt.Errorf("could not fetch SIF info: %v", err)
	}

	path := filepath.Join(location, info.Sha256)
	glog.V(5).Infof("Renaming %s to %s", pullPath, path)
	err = os.Rename(pullPath, path)
	if err != nil {
		cleanup()
		return nil, fmt.Errorf("could not save pulled image: %v", err)
	}

	info.Path = path
	info.Ref = ref
	return info, nil
}

// LibraryInfo queries remote library to get info about the image.
// If image is not found returns ErrNotFound. For references other than
// library returns ErrNotLibrary.
func LibraryInfo(ctx context.Context, ref *Reference, auth *k8s.AuthConfig) (*Info, error) {
	if ref.URI() != singularity.LibraryDomain {
		return nil, ErrNotLibrary
	}

	pullURL := strings.TrimPrefix(ref.String(), ref.URI()+"/")
	config := &library.Config{
		BaseURL:   auth.GetServerAddress(),
		AuthToken: auth.GetPassword(),
	}
	client, err := library.NewClient(config)
	if err != nil {
		return nil, fmt.Errorf("could not create library client: %v", err)
	}
	img, err := client.GetImage(ctx, runtime.GOARCH, pullURL)
	if err == library.ErrNotFound {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("could not get library image info: %v", err)
	}

	// library API uses sha256 hash func and returns image hash in form sha256.<hash>
	// we need to trim it before it can be used
	id := strings.TrimPrefix(img.Hash, "sha256.")
	return &Info{
		ID:     id,
		Sha256: id,
		Size:   uint64(img.Size),
		Ref:    ref,
	}, nil
}

// Remove removes image from the host filesystem. It makes sure
// no one relies on image file and if this check fails it returns ErrIsUsed error.
// Local SIF images that were not pulled by CRI are never actually removed.
func (i *Info) Remove() error {
	if i.Ref.URI() == singularity.LocalFileDomain {
		return nil
	}

	i.mu.RLock()
	defer i.mu.RUnlock()

	if len(i.usedBy) > 0 {
		return ErrIsUsed
	}

	err := os.Remove(i.Path)
	if err != nil {
		return fmt.Errorf("could not remove image: %v", err)
	}
	return nil
}

// Verify verifies image signatures.
func (i *Info) Verify() error {
	if i.Ref.URI() == singularity.DockerDomain {
		return nil
	}

	_, _, err := signing.Verify(context.Background(),i.Path, singularity.KeysServer, 0, false, false, "", false, true)
	noSignatures := err != nil && strings.Contains(err.Error(), "no signatures found")
	if noSignatures {
		glog.V(2).Infof("Image %s is not signed", i.Ref)
	}
	if err != nil && !noSignatures {
		return fmt.Errorf("SIF verification failed: %v", err)
	}
	return nil
}

// Matches tests image against passed filter and returns true if it matches.
func (i *Info) Matches(filter *k8s.ImageFilter) bool {
	if filter == nil || filter.Image == nil {
		return true
	}
	ref := filter.Image.Image
	if strings.HasPrefix(i.ID, ref) {
		return true
	}
	for _, tag := range i.Ref.tags {
		if strings.HasPrefix(tag, ref) {
			return true
		}
	}
	for _, digest := range i.Ref.digests {
		if strings.HasPrefix(digest, ref) {
			return true
		}
	}
	return false
}

func pullImage(ctx context.Context, ref *Reference, auth *k8s.AuthConfig, pullPath string) error {
	pullURL := strings.TrimPrefix(ref.String(), ref.URI()+"/")
	switch ref.URI() {
	case singularity.LibraryDomain:
		config := &library.Config{
			BaseURL:   auth.GetServerAddress(),
			AuthToken: auth.GetPassword(),
		}
		client, err := library.NewClient(config)
		if err != nil {
			return fmt.Errorf("could not create library client: %v", err)
		}
		w, err := os.Create(pullPath)
		if err != nil {
			return fmt.Errorf("could not create file to pull image: %v", err)
		}
		parts := strings.Split(pullURL, ":")
		// don't check index out of range since we add :latest by default when parsing ref
		err = client.DownloadImage(ctx, w, runtime.GOARCH, parts[0], parts[1], nil)
		_ = w.Close()
		if err != nil {
			return fmt.Errorf("could not pull library image: %v", err)
		}
	case singularity.DockerDomain:
		var errMsg bytes.Buffer
		if auth.GetServerAddress() != "" {
			pullURL = fmt.Sprintf("%s/%s", auth.GetServerAddress(), pullURL)
		}
		remote := fmt.Sprintf("%s://%s", singularity.DockerProtocol, pullURL)
		buildCmd := exec.CommandContext(ctx, singularity.RuntimeName, "build", "-F", pullPath, remote)
		buildCmd.Env = []string{
			fmt.Sprintf("PATH=%s", os.Getenv("PATH")),
			// assume auth.Auth is not needed b/c k8s decodes it into username and password,
			// see https://github.com/kubernetes/kubernetes/blob/master/pkg/credentialprovider/config.go#L284
			fmt.Sprintf("%s=%s", singularity.EnvDockerUsername, auth.GetUsername()),
			fmt.Sprintf("%s=%s", singularity.EnvDockerPassword, auth.GetPassword()),
		}
		buildCmd.Stderr = &errMsg
		buildCmd.Stdout = ioutil.Discard
		err := buildCmd.Run()
		if err != nil {
			return fmt.Errorf("could not build image: %s", &errMsg)
		}
	default:
		return fmt.Errorf("unknown image registry: %s", ref.URI())
	}
	return nil
}

func sifInfo(sifPath string) (*Info, error) {
	sif, err := os.Open(sifPath)
	if err != nil {
		return nil, fmt.Errorf("could not open sif image: %v", err)
	}

	fi, err := sif.Stat()
	if err != nil {
		return nil, fmt.Errorf("could not fetch file info: %v", err)
	}

	h := sha256.New()
	_, err = io.Copy(h, sif)
	if err != nil {
		return nil, fmt.Errorf("could not get sif image digest: %v", err)
	}
	checksum := fmt.Sprintf("%x", h.Sum(nil))

	err = sif.Close()
	if err != nil {
		return nil, fmt.Errorf("could not close pulled image: %v", err)
	}

	ociConfig, err := fetchOCIConfig(sifPath)
	if err != nil {
		glog.Errorf("Could not fetch OCI config for image %s: %v", sifPath, err)
	}

	return &Info{
		ID:        checksum,
		Sha256:    checksum,
		Size:      uint64(fi.Size()),
		Path:      sifPath,
		OciConfig: ociConfig,
	}, nil
}

func fetchOCIConfig(imgPath string) (*specs.ImageConfig, error) {
	const ociConfigSection = "oci-config.json"

	img, err := image.Init(imgPath, false)
	if err != nil {
		return nil, fmt.Errorf("failed to load SIF image %s: %v", imgPath, err)
	}
	defer img.File.Close()

	reader, err := image.NewSectionReader(img, ociConfigSection, -1)
	if err != nil {
		if err == image.ErrNoSection {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to read %s section: %v", ociConfigSection, err)
	}

	var imgConfig specs.ImageConfig
	err = json.NewDecoder(reader).Decode(&imgConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s section: %v", ociConfigSection, err)
	}

	return &imgConfig, nil
}
EOF   
    make && make install

    cd /opt/singularity
    ./mconfig
    make -C builddir
    make -C builddir install

    unset HOME

    cat > /etc/sykube/kubeadm.yml <<EOF
apiVersion: kubeadm.k8s.io/v1beta2
kind: InitConfiguration
nodeRegistration:
  criSocket: /var/run/singularity.sock
---
apiVersion: kubeadm.k8s.io/v1beta2
kind: ClusterConfiguration
kubernetesVersion: v1.21.0
networking:
  podSubnet: 10.244.0.0/16
---
apiVersion: kubeadm.k8s.io/v1beta2
kind: JoinConfiguration
nodeRegistration:
  criSocket: /var/run/singularity.sock
EOF

    cat > /etc/sykube/admin-user.yml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
EOF

    cat > /etc/sykube/admin-role.yml <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
EOF

    mkdir -p /etc/cni/net.d

    apt-get clean
    apt-get autoclean

    cat > /etc/cni/net.d/00_bridge.conflist <<EOF
{
    "cniVersion": "0.3.1",
    "name": "bridge",
    "plugins": [
        {
            "type": "loopback"
        },
        {
            "type": "bridge",
            "bridge": "cbr0",
            "isGateway": true,
            "isDefaultGateway": true,
            "ipMasq": true,
            "capabilities": {"ipRanges": true},
            "ipam": {
                "type": "host-local",
                "routes": [
                    {
                        "dst": "0.0.0.0/0"
                    }
                ]
            }
        },
        {
            "type": "portmap",
            "capabilities": {"portMappings": true},
            "snat": true
        }
    ]
}
EOF

%startscript
    mount -t tmpfs tmpfs -o nosuid,nodev,mode=755 /run
    mkdir /run/lock
    mkdir /run/flannel
    mount -t tmpfs tmpfs -o nosuid,nodev,noexec,relatime,size=5120k /run/lock
    mount --make-rshared /
    mkdir -p /var/log/supervisor 
    exec supervisord

%runscript
    for p in `pgrep --ns $$ -v`; do
        if ls -la /proc/$p/root/lib/modules/`uname -r` >/dev/null 2>&1; then
            break
        fi
    done
    dest=`realpath --relative-base="/proc/$p/root" "/usr/local/bin" 2>/dev/null`
    if [ ! -z "${dest}" ]; then
        if cp --preserve=mode /etc/sykube/sykube "/proc/$p/root/${dest}/sykube"; then
            echo "sykube is now installed in ${dest}"
            exit
        fi
    else
        echo "could not install sykube in /usr/local/bin"
    fi
    exit 1
